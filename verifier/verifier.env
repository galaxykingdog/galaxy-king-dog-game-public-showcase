// verifier/server.js
require("dotenv").config();

const express = require("express");
const cors = require("cors");
const crypto = require("crypto");
const nacl = require("tweetnacl");
const { Connection, clusterApiUrl, Keypair, PublicKey } = require("@solana/web3.js");

const app = express();
app.use(cors());
app.use(express.json({ limit: "6mb" }));

// --- config ---
const CLUSTER = (process.env.CLUSTER || "devnet").trim();
const RPC_URL = (process.env.RPC_URL || "").trim() || clusterApiUrl(CLUSTER);
const POOL_RECIPIENT = (process.env.POOL_RECIPIENT || "").trim();
const EXPECTED_GAME_ID = (process.env.EXPECTED_GAME_ID || "").trim();

if (!POOL_RECIPIENT) {
  console.error("Missing POOL_RECIPIENT in .env");
  process.exit(1);
}

const connection = new Connection(RPC_URL, "confirmed");

// --- helpers ---
function sha256Hex(s) {
  return crypto.createHash("sha256").update(String(s), "utf8").digest("hex");
}

function asInt(n, def = 0) {
  const x = Number(n);
  return Number.isFinite(x) ? Math.trunc(x) : def;
}

function loadVerifierKeypair() {
  const b64 = (process.env.VERIFIER_SECRET_KEY_B64 || "").trim();
  if (b64) {
    const u8 = Uint8Array.from(Buffer.from(b64, "base64"));
    return Keypair.fromSecretKey(u8);
  }

  // fallback: ephemeral dev key (OK for devnet, όχι για mainnet)
  const kp = Keypair.generate();
  console.log("⚠️ No VERIFIER_SECRET_KEY_B64 set. Generated ephemeral verifier key (dev only).");
  console.log("Verifier pubkey:", kp.publicKey.toBase58());
  console.log("To persist, set VERIFIER_SECRET_KEY_B64 to:");
  console.log(Buffer.from(kp.secretKey).toString("base64"));
  return kp;
}

const VERIFIER = loadVerifierKeypair();

async function verifyEntryTx({ entry_sig, player_pubkey, minLamports, poolRecipient }) {
  const tx = await connection.getParsedTransaction(entry_sig, {
    maxSupportedTransactionVersion: 0,
    commitment: "confirmed",
  });

  if (!tx) throw new Error("Entry tx not found on cluster/RPC yet (try again in a moment).");
  if (tx.meta && tx.meta.err) throw new Error("Entry tx has error (meta.err not null).");

  const ixs = (tx.transaction && tx.transaction.message && tx.transaction.message.instructions) || [];
  let ok = false;

  for (const ix of ixs) {
    if (ix.program === "system" && ix.parsed && ix.parsed.type === "transfer") {
      const info = ix.parsed.info || {};
      const src = String(info.source || "");
      const dst = String(info.destination || "");
      const lamports = asInt(info.lamports, -1);

      if (src === player_pubkey && dst === poolRecipient && lamports >= minLamports) {
        ok = true;
        break;
      }
    }
  }

  if (!ok) {
    throw new Error("Entry tx does not contain required SystemProgram transfer (source/dest/lamports).");
  }

  return { slot: tx.slot };
}

function buildReplayMaterial(body) {
  // ΠΡΟΣΟΧΗ: κρατάμε ίδιο key order όπως στο client
  return JSON.stringify({
    schema: asInt(body.schema, 0),
    game_id: String(body.game_id || ""),
    version_hash: String(body.version_hash || ""),
    seed: (asInt(body.seed, 0) >>> 0),
    masks_b64: String(body.masks_b64 || ""),
    deltas_b64: String(body.deltas_b64 || ""),
  });
}

function buildRunMaterial(body, replay_hash) {
  // ίδιο join() format με client
  const player_pubkey = String(body.player_pubkey || "");
  const game_id = String(body.game_id || "");
  const season_id = String(asInt(body.season_id, 0));
  const fee_lamports = String(asInt(body.fee_lamports, 0));
  const entry_sig = String(body.entry_sig || "");
  const entry_slot = String(asInt(body.entry_slot, 0));
  const final_score = String(asInt(body.final_score, 0));
  const versionHash = String(body.version_hash || "");

  return [
    player_pubkey,
    game_id,
    season_id,
    fee_lamports,
    entry_sig,
    entry_slot,
    final_score,
    replay_hash,
    versionHash,
  ].join("|");
}

function signText(text) {
  const msg = Buffer.from(String(text), "utf8");
  const sig = nacl.sign.detached(msg, VERIFIER.secretKey);
  return Buffer.from(sig).toString("base64");
}

// --- routes ---
app.get("/health", (req, res) => {
  res.json({
    ok: true,
    cluster: CLUSTER,
    rpcUrl: RPC_URL,
    poolRecipient: POOL_RECIPIENT,
    verifier_pubkey: VERIFIER.publicKey.toBase58(),
  });
});

app.post("/verify", async (req, res) => {
  try {
    const body = req.body || {};

    // basic required fields
    const game_id = String(body.game_id || "");
    const player_pubkey = String(body.player_pubkey || "");
    const entry_sig = String(body.entry_sig || "");
    const fee_lamports = asInt(body.fee_lamports, 0);
    const client_run_hash = String(body.run_hash || "");
    const client_replay_hash = String(body.replay_hash || "");

    if (!game_id || !player_pubkey || !entry_sig || !client_run_hash || !client_replay_hash) {
      throw new Error("Missing required fields (game_id/player_pubkey/entry_sig/run_hash/replay_hash).");
    }

    if (EXPECTED_GAME_ID && game_id !== EXPECTED_GAME_ID) {
      throw new Error("Unexpected game_id.");
    }

    // verify pubkeys parse
    new PublicKey(player_pubkey);
    new PublicKey(POOL_RECIPIENT);

    // 1) integrity: version_hash consistency (weak check but useful)
    const computedVersionHash = sha256Hex(String(body.game_version || ""));
    if (String(body.version_hash || "") !== computedVersionHash) {
      throw new Error("version_hash mismatch (server recompute != client version_hash).");
    }

    // 2) integrity: replay_hash
    const replayMaterial = buildReplayMaterial(body);
    const replay_hash = sha256Hex(replayMaterial);
    if (replay_hash !== client_replay_hash) {
      throw new Error("replay_hash mismatch.");
    }

    // 3) integrity: run_hash
    const runMaterial = buildRunMaterial(body, replay_hash);
    const run_hash = sha256Hex(runMaterial);
    if (run_hash !== client_run_hash) {
      throw new Error("run_hash mismatch.");
    }

    // 4) verify entry fee tx on Solana
    const txInfo = await verifyEntryTx({
      entry_sig,
      player_pubkey,
      minLamports: fee_lamports,
      poolRecipient: POOL_RECIPIENT,
    });

    // 5) build memo + signature (για on-chain anchor στο επόμενο βήμα)
    const memoText = [
      "GKD",
      "v1",
      `run=${run_hash}`,
      `replay=${replay_hash}`,
      `season=${asInt(body.season_id, 0)}`,
      `fee=${fee_lamports}`,
      `score=${asInt(body.final_score, 0)}`,
      `entry=${entry_sig}`,
      `slot=${txInfo.slot}`,
      `verifier=${VERIFIER.publicKey.toBase58()}`,
    ].join("|");

    const verifier_sig = signText(memoText);

    res.json({
      ok: true,
      cluster: CLUSTER,
      verifier_pubkey: VERIFIER.publicKey.toBase58(),
      verifier_sig,     // base64 ed25519 signature over memoText
      memoText,         // what we will anchor on-chain (Memo program) στο Step 3
      observed_entry_slot: txInfo.slot,
      run_hash,
      replay_hash,
    });
  } catch (e) {
    res.status(400).json({ ok: false, error: String(e && e.message ? e.message : e) });
  }
});

const PORT = asInt(process.env.PORT, 8787);
app.listen(PORT, () => {
  console.log(`Verifier listening on http://127.0.0.1:${PORT}`);
});
